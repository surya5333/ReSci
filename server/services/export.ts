export interface ExportOptions {
  format: 'pdf' | 'docx' | 'json' | 'txt';
  includeCitations: boolean;
  includeEquipment: boolean;
  includeCostEstimates: boolean;
}

export interface ProtocolData {
  title: string;
  methods: any[];
  sampleSize?: any;
  content: any;
}

export async function exportProtocol(data: ProtocolData, options: ExportOptions): Promise<Buffer | string> {
  switch (options.format) {
    case 'json':
      return exportToJSON(data, options);
    case 'txt':
      return exportToText(data, options);
    case 'pdf':
      return exportToPDF(data, options);
    case 'docx':
      return exportToDocx(data, options);
    default:
      throw new Error(`Unsupported export format: ${options.format}`);
  }
}

function exportToJSON(data: ProtocolData, options: ExportOptions): string {
  const exportData = {
    title: data.title,
    generatedAt: new Date().toISOString(),
    methods: data.methods,
    sampleSize: data.sampleSize,
    options: options,
    content: data.content
  };
  
  return JSON.stringify(exportData, null, 2);
}

function exportToText(data: ProtocolData, options: ExportOptions): string {
  let text = `${data.title}\n`;
  text += `Generated by RESAI on ${new Date().toLocaleDateString()}\n`;
  text += `${'='.repeat(50)}\n\n`;

  // Add methods
  text += `RESEARCH METHODS\n`;
  text += `${'-'.repeat(20)}\n`;
  
  if (data.methods && data.methods.length > 0) {
    data.methods.forEach((method, index) => {
      text += `\n${index + 1}. ${method.title || 'Untitled Method'}\n`;
      text += `${method.description || 'No description available'}\n`;
      
      if (method.pros && method.pros.length > 0) {
        text += `\nAdvantages:\n`;
        method.pros.forEach((pro: string) => text += `- ${pro}\n`);
      }
      
      if (method.cons && method.cons.length > 0) {
        text += `\nDisadvantages:\n`;
        method.cons.forEach((con: string) => text += `- ${con}\n`);
      }
      
      if (options.includeCitations && method.citations && method.citations.length > 0) {
        text += `\nReferences:\n`;
        method.citations.forEach((citation: string) => text += `- ${citation}\n`);
      }
      
      text += `\n`;
    });
  }

  // Add sample size if available
  if (data.sampleSize) {
    text += `\nSAMPLE SIZE CALCULATION\n`;
    text += `${'-'.repeat(25)}\n`;
    text += `Required sample size: ${data.sampleSize.sampleSize || 'Not calculated'}\n`;
    text += `Total participants: ${data.sampleSize.totalSampleSize || 'Not calculated'}\n`;
    text += `Adjusted for dropout: ${data.sampleSize.adjustedSampleSize || 'Not calculated'}\n`;
    text += `Statistical power: ${data.sampleSize.power || 'Not specified'}\n`;
    text += `Alpha level: ${data.sampleSize.alpha || 'Not specified'}\n`;
    text += `Effect size: ${data.sampleSize.effectSize || 'Not specified'}\n`;
  }

  // Add equipment list if requested
  if (options.includeEquipment) {
    text += `\nEQUIPMENT AND MATERIALS\n`;
    text += `${'-'.repeat(25)}\n`;
    text += `- Equipment list will be generated based on selected methods\n`;
    text += `- Contact lab manager for specific requirements\n`;
    text += `- Ensure all safety protocols are followed\n\n`;
  }

  // Add cost estimates if requested
  if (options.includeCostEstimates) {
    text += `\nCOST ESTIMATES\n`;
    text += `${'-'.repeat(15)}\n`;
    text += `- Detailed cost breakdown available upon request\n`;
    text += `- Contact research administration for budget planning\n\n`;
  }

  text += `\nGenerated by RESAI Research Planning Assistant\n`;
  text += `For questions or support, contact your research team.\n`;

  return text;
}

function exportToPDF(data: ProtocolData, options: ExportOptions): Buffer {
  // In a real implementation, you'd use a library like puppeteer or jsPDF
  // For now, we'll return a simple text-based "PDF" as a buffer
  const textContent = exportToText(data, options);
  return Buffer.from(textContent, 'utf-8');
}

function exportToDocx(data: ProtocolData, options: ExportOptions): Buffer {
  // In a real implementation, you'd use a library like docx or officegen
  // For now, we'll return the text content as a buffer
  const textContent = exportToText(data, options);
  return Buffer.from(textContent, 'utf-8');
}

export function getExportMimeType(format: string): string {
  switch (format) {
    case 'pdf':
      return 'application/pdf';
    case 'docx':
      return 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';
    case 'json':
      return 'application/json';
    case 'txt':
    default:
      return 'text/plain';
  }
}

export function getExportFilename(title: string, format: string): string {
  const sanitizedTitle = title.toLowerCase().replace(/[^a-z0-9]/g, '_');
  const timestamp = new Date().toISOString().split('T')[0];
  return `${sanitizedTitle}_${timestamp}.${format}`;
}
